<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Maritime Particle System</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- MediaPipe Hands -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: 'Segoe UI', sans-serif; }
        #canvas-container { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; }
        #input_video { display: none; } /* 隐藏原始摄像头画面 */
        
        /* 自定义滚动条 */
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: rgba(255, 255, 255, 0.1); }
        ::-webkit-scrollbar-thumb { background: rgba(255, 255, 255, 0.3); border-radius: 4px; }

        .glass-panel {
            background: rgba(20, 24, 35, 0.7);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.37);
        }

        .loader {
            border: 4px solid rgba(255, 255, 255, 0.1);
            border-left-color: #3b82f6;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>
</head>
<body>

    <!-- 摄像头输入 (隐藏) -->
    <video id="input_video"></video>

    <!-- 3D 画布 -->
    <div id="canvas-container"></div>

    <!-- 加载遮罩 -->
    <div id="loader-overlay" class="fixed inset-0 z-50 flex flex-col items-center justify-center bg-black text-white transition-opacity duration-500">
        <div class="loader mb-4"></div>
        <p class="text-sm tracking-widest uppercase text-blue-400">初始化视觉核心...</p>
        <p class="text-xs text-gray-500 mt-2">请允许摄像头权限以启用手势控制</p>
    </div>

    <!-- UI 控制面板 -->
    <div class="absolute top-6 left-6 z-20 w-72 glass-panel rounded-xl p-5 text-white transition-all hover:bg-opacity-80">
        <div class="flex justify-between items-center mb-4">
            <h1 class="text-lg font-bold tracking-wider flex items-center gap-2">
                <svg class="w-5 h-5 text-blue-400" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z"></path></svg>
                粒子交互系统
            </h1>
            <div id="status-dot" class="w-2 h-2 rounded-full bg-red-500 shadow-[0_0_8px_rgba(239,68,68,0.8)]" title="未检测到手势"></div>
        </div>

        <div class="space-y-5">
            <!-- 模型选择 -->
            <div>
                <label class="text-xs text-gray-400 uppercase font-semibold mb-2 block">全息模型</label>
                <div class="grid grid-cols-3 gap-2">
                    <button onclick="changeShape('ship')" class="shape-btn bg-white/10 hover:bg-blue-600/80 py-2 rounded text-xs transition border border-white/5 active:scale-95 focus:ring-1 ring-blue-400">船舶</button>
                    <button onclick="changeShape('anchor')" class="shape-btn bg-white/10 hover:bg-blue-600/80 py-2 rounded text-xs transition border border-white/5 active:scale-95">船锚</button>
                    <button onclick="changeShape('helm')" class="shape-btn bg-white/10 hover:bg-blue-600/80 py-2 rounded text-xs transition border border-white/5 active:scale-95">船舵</button>
                </div>
            </div>

            <!-- 颜色选择 -->
            <div>
                <label class="text-xs text-gray-400 uppercase font-semibold mb-2 block">粒子光谱</label>
                <div class="flex items-center gap-3">
                    <input type="color" id="colorPicker" value="#00ffff" class="w-8 h-8 rounded cursor-pointer bg-transparent border-0 p-0 overflow-hidden">
                    <span class="text-xs text-gray-300 font-mono" id="colorValue">#00FFFF</span>
                </div>
            </div>

            <!-- 信息反馈 -->
            <div class="bg-black/30 rounded p-3 border border-white/5">
                <p class="text-xs text-gray-400 mb-1">交互状态:</p>
                <p id="gesture-info" class="text-sm font-mono text-blue-300">等待摄像头输入...</p>
            </div>
            
             <!-- 全屏按钮 -->
             <button onclick="toggleFullScreen()" class="w-full py-2 border border-white/10 rounded text-xs hover:bg-white/5 transition flex justify-center items-center gap-2">
                <svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 8V4m0 0h4M4 4l5 5m11-1V4m0 0h-4m4 0l-5 5M4 16v4m0 0h4m-4 0l5-5m11 5l-5-5m5 5v-4m0 4h-4"></path></svg>
                全屏沉浸模式
            </button>
        </div>
    </div>

    <script>
        // --- 全局变量 ---
        let scene, camera, renderer, particles;
        let targetPositions = []; // 目标形状的点坐标
        let currentPositions = []; // 当前点坐标
        let particleCount = 5000; // 粒子数量
        let geometry;
        let material;
        
        // 交互变量
        let handInteractionFactor = 0; // 0 = 聚合, 1 = 扩散
        let isHandDetected = false;
        let clock = new THREE.Clock();

        // --- 1. Three.js 初始化 ---
        function initThree() {
            const container = document.getElementById('canvas-container');
            
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x050505, 0.02);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 30;
            camera.position.y = 5;

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            container.appendChild(renderer.domElement);

            // 创建粒子系统
            createParticleSystem();

            // 灯光 (虽然PointsMaterial不直接受光照影响，但为了后续扩展)
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);

            // 响应窗口大小变化
            window.addEventListener('resize', onWindowResize, false);

            // 初始生成船舶
            generateTargetShape('ship');
            
            animate();
        }

        function createParticleSystem() {
            geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            
            // 初始随机分布
            for (let i = 0; i < particleCount; i++) {
                positions[i * 3] = (Math.random() - 0.5) * 50;
                positions[i * 3 + 1] = (Math.random() - 0.5) * 50;
                positions[i * 3 + 2] = (Math.random() - 0.5) * 50;
                
                currentPositions.push({
                    x: positions[i * 3],
                    y: positions[i * 3 + 1],
                    z: positions[i * 3 + 2],
                    vx: 0, vy: 0, vz: 0 // 速度
                });
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

            // 使用贴图会让粒子更好看，这里用简单的Canvas生成发光点
            const sprite = getSprite();

            material = new THREE.PointsMaterial({
                color: 0x00ffff,
                size: 0.6,
                map: sprite,
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });

            particles = new THREE.Points(geometry, material);
            scene.add(particles);
        }

        // 生成圆形发光纹理
        function getSprite() {
            const canvas = document.createElement('canvas');
            canvas.width = 32;
            canvas.height = 32;
            const context = canvas.getContext('2d');
            const gradient = context.createRadialGradient(16, 16, 0, 16, 16, 16);
            gradient.addColorStop(0, 'rgba(255,255,255,1)');
            gradient.addColorStop(0.2, 'rgba(255,255,255,0.8)');
            gradient.addColorStop(0.5, 'rgba(255,255,255,0.2)');
            gradient.addColorStop(1, 'rgba(0,0,0,0)');
            context.fillStyle = gradient;
            context.fillRect(0, 0, 32, 32);
            const texture = new THREE.Texture(canvas);
            texture.needsUpdate = true;
            return texture;
        }

        // --- 2. 形状生成逻辑 (程序化几何) ---
        
        function generateTargetShape(type) {
            targetPositions = [];
            const scale = 12; // 基础缩放

            for (let i = 0; i < particleCount; i++) {
                let x, y, z;
                const t = i / particleCount; // 0 to 1
                
                if (type === 'ship') {
                    // 简化的船体参数方程
                    // 底部是拉伸的半椭圆，顶部甲板
                    const layer = Math.floor(t * 20); // 分层
                    const progressInLayer = (t * 20) % 1;
                    
                    // 船身主体
                    if (t < 0.7) {
                        const u = (t / 0.7) * Math.PI; // 0 to PI
                        const v = Math.random() * Math.PI; 
                        
                        // 船形轮廓
                        const width = Math.sin(u) * 3;
                        const length = Math.cos(u) * 10;
                        const height = (u / Math.PI) * 4;

                        x = length + (Math.random() - 0.5);
                        y = height - 2;
                        z = (Math.random() - 0.5) * width * 2 * Math.sin(height/4 * Math.PI);
                    } else {
                        // 桅杆
                        x = (Math.random() - 0.5) * 0.5;
                        y = 2 + Math.random() * 8;
                        z = 0;
                        
                        // 帆 (横向)
                        if (Math.random() > 0.5) {
                             x = (Math.random() - 0.5) * (6 - (y-2)/2);
                             z = (Math.random() - 0.5) * 0.5; 
                        }
                    }
                } 
                else if (type === 'anchor') {
                    // 锚
                    const rand = Math.random();
                    if (rand < 0.5) {
                        // 垂直轴
                        x = (Math.random() - 0.5);
                        y = (Math.random() * 12) - 6;
                        z = (Math.random() - 0.5);
                    } else if (rand < 0.7) {
                        // 顶部环
                        const theta = Math.random() * Math.PI * 2;
                        x = Math.cos(theta) * 1.5;
                        y = 6 + Math.sin(theta) * 1.5;
                        z = 0;
                    } else if (rand < 0.85) {
                        // 横杆
                        x = (Math.random() - 0.5) * 8;
                        y = 3;
                        z = (Math.random() - 0.5);
                    } else {
                        // 底部弧形
                        const theta = Math.PI + (Math.random() * Math.PI); // 下半圆
                        x = Math.cos(theta) * 5;
                        y = -4 + Math.sin(theta) * 4;
                        z = 0;
                    }
                }
                else if (type === 'helm') {
                    // 船舵 (Wheel)
                    const rand = Math.random();
                    if (rand < 0.6) {
                        // 外环 (Torus)
                        const theta = Math.random() * Math.PI * 2;
                        const phi = Math.random() * Math.PI * 2;
                        const R = 7;
                        const r = 0.6;
                        x = (R + r * Math.cos(phi)) * Math.cos(theta);
                        y = (R + r * Math.cos(phi)) * Math.sin(theta);
                        z = r * Math.sin(phi);
                    } else if (rand < 0.7) {
                        // 中心毂
                        const theta = Math.random() * Math.PI * 2;
                        const r = Math.random() * 1.5;
                        x = r * Math.cos(theta);
                        y = r * Math.sin(theta);
                        z = (Math.random() - 0.5) * 2;
                    } else {
                        // 辐条 (8根)
                        const spoke = Math.floor(Math.random() * 8);
                        const angle = (spoke / 8) * Math.PI * 2;
                        const dist = Math.random() * 7;
                        x = Math.cos(angle) * dist + (Math.random()-0.5)*0.5;
                        y = Math.sin(angle) * dist + (Math.random()-0.5)*0.5;
                        z = (Math.random() - 0.5) * 0.5;
                    }
                }

                targetPositions.push({ x: x * 1.5, y: y * 1.5, z: z * 1.5 }); // 稍微放大
            }
        }

        // --- 3. UI 交互逻辑 ---
        
        function changeShape(type) {
            generateTargetShape(type);
            
            // UI 按钮样式更新
            document.querySelectorAll('.shape-btn').forEach(btn => {
                btn.classList.remove('bg-blue-600/80', 'ring-1', 'ring-blue-400');
                if(btn.innerText.includes(type === 'ship' ? '船舶' : type === 'anchor' ? '船锚' : '船舵')) {
                    btn.classList.add('bg-blue-600/80', 'ring-1', 'ring-blue-400');
                }
            });
        }

        // 颜色选择器
        document.getElementById('colorPicker').addEventListener('input', (e) => {
            const color = e.target.value;
            material.color.set(color);
            document.getElementById('colorValue').innerText = color.toUpperCase();
        });

        function toggleFullScreen() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen();
            } else {
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                }
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- 4. 动画循环与粒子更新 ---

        function animate() {
            requestAnimationFrame(animate);

            const time = clock.getElapsedTime();
            const positions = geometry.attributes.position.array;
            
            // 摄像机缓慢旋转
            const camRadius = 30 + handInteractionFactor * 10; // 扩散时摄像机拉远
            camera.position.x = Math.sin(time * 0.2) * camRadius;
            camera.position.z = Math.cos(time * 0.2) * camRadius;
            camera.lookAt(0, 0, 0);

            // 更新每个粒子
            for (let i = 0; i < particleCount; i++) {
                const p = currentPositions[i];
                const t = targetPositions[i];

                // 1. 基础形状插值 (Lerp to target)
                // 如果手势扩散，目标变为随机位置
                let tx, ty, tz;

                if (handInteractionFactor > 0.1) {
                    // 手势控制扩散逻辑
                    // 基于原本目标位置 + 沿法线方向爆炸 + 随机噪点
                    const explodeStrength = handInteractionFactor * 25;
                    tx = t.x + (Math.random() - 0.5) * explodeStrength;
                    ty = t.y + (Math.random() - 0.5) * explodeStrength;
                    tz = t.z + (Math.random() - 0.5) * explodeStrength;
                } else {
                    // 正常形态
                    tx = t.x;
                    ty = t.y;
                    tz = t.z;

                    // 添加少许 "海水" 浮动效果
                    ty += Math.sin(time * 2 + p.x * 0.5) * 0.2;
                }

                // 简单的物理缓动
                p.x += (tx - p.x) * 0.05;
                p.y += (ty - p.y) * 0.05;
                p.z += (tz - p.z) * 0.05;

                positions[i * 3] = p.x;
                positions[i * 3 + 1] = p.y;
                positions[i * 3 + 2] = p.z;
            }

            geometry.attributes.position.needsUpdate = true;
            
            // 粒子整体自旋
            if (handInteractionFactor < 0.2) {
                particles.rotation.y += 0.002;
            }
            
            renderer.render(scene, camera);
        }

        // --- 5. MediaPipe Hands 集成 ---
        
        function setupMediaPipe() {
            const videoElement = document.getElementById('input_video');
            const statusDot = document.getElementById('status-dot');
            const gestureInfo = document.getElementById('gesture-info');
            const loader = document.getElementById('loader-overlay');

            const hands = new Hands({locateFile: (file) => {
                return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
            }});

            hands.setOptions({
                maxNumHands: 2,
                modelComplexity: 1,
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });

            hands.onResults(onResults);

            const cameraUtils = new Camera(videoElement, {
                onFrame: async () => {
                    await hands.send({image: videoElement});
                },
                width: 640,
                height: 480
            });

            cameraUtils.start()
                .then(() => {
                    loader.style.opacity = '0';
                    setTimeout(() => loader.style.display = 'none', 500);
                })
                .catch(err => {
                    console.error(err);
                    gestureInfo.innerText = "摄像头访问失败，使用鼠标模式";
                    gestureInfo.classList.add('text-red-400');
                    loader.style.display = 'none';
                });

            function onResults(results) {
                const landmarks = results.multiHandLandmarks;
                
                if (landmarks && landmarks.length > 0) {
                    isHandDetected = true;
                    statusDot.classList.remove('bg-red-500', 'shadow-[0_0_8px_rgba(239,68,68,0.8)]');
                    statusDot.classList.add('bg-green-500', 'shadow-[0_0_8px_rgba(34,197,94,0.8)]');

                    // 逻辑：
                    // 1. 如果双手：计算两只手腕 (索引0) 的距离
                    // 2. 如果单手：计算拇指 (4) 和食指 (8) 的距离
                    
                    let distance = 0;

                    if (landmarks.length === 2) {
                        const hand1 = landmarks[0][0]; // Wrist
                        const hand2 = landmarks[1][0]; // Wrist
                        
                        // 计算 3D 空间距离的近似值 (仅取XY，Z不太准)
                        const dx = hand1.x - hand2.x;
                        const dy = hand1.y - hand2.y;
                        const d = Math.sqrt(dx*dx + dy*dy);
                        
                        // 映射距离到因子 (大约 0.1 到 0.8 是有效区间)
                        // 距离越大，因子越大 (扩散)
                        distance = Math.max(0, Math.min(1, (d - 0.2) * 2));
                        gestureInfo.innerText = `双掌距离: ${(d*100).toFixed(0)}% - ${distance > 0.5 ? '扩散' : '聚合'}`;

                    } else {
                        const hand = landmarks[0];
                        const thumb = hand[4];
                        const index = hand[8];

                        const dx = thumb.x - index.x;
                        const dy = thumb.y - index.y;
                        const d = Math.sqrt(dx*dx + dy*dy);
                        
                        // 单手捏合：捏合(小距离) = 0，张开(大距离) = 1
                        distance = Math.max(0, Math.min(1, (d - 0.05) * 4));
                        gestureInfo.innerText = `手指张合: ${(distance*100).toFixed(0)}%`;
                    }

                    // 平滑处理因子，避免跳变
                    handInteractionFactor += (distance - handInteractionFactor) * 0.1;

                } else {
                    isHandDetected = false;
                    statusDot.classList.add('bg-red-500');
                    statusDot.classList.remove('bg-green-500');
                    gestureInfo.innerText = "未检测到手势 (将双手放入画面)";
                    
                    // 无手势时，自动回缩
                    handInteractionFactor += (0 - handInteractionFactor) * 0.05;
                }
            }
        }

        // 启动应用
        initThree();
        setupMediaPipe();

    </script>
</body>
</html>